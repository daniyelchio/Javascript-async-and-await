<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Async and Await Function</title>
    <link rel="stylesheet" href="app.css">
</head>

<body>
    <nav id="navbar">
        <header>
            <h2>Navigation</h2>
        </header>
        <ul>
            <li><a href="#promises" class="nav-link">Promise</a></li>
            <li><a href="#async" class="nav-link">Async</a></li>
            <li><a href="#await" class="nav-link">Await</a></li>
            <li><a href="#error_handling" class="nav-link">Error Handling</a></li>
            <li><a href="#summary" class="nav-link">Summary</a></li>
        </ul>
        </li>
    </nav>

    <main id="main-doc">
        <section class="main-section" id="promises">
            <header>
                <h1>Promises</h1>
            </header>
            <article>
                <p>
                    A <b>promise</b> object is the eventual completion or failure of an asynchronous operation and its resulting value. Compared to a callback approach where it is
                    passed into a function and then and then is called upon completion, a promise attaches callbacks on the return promise object. Promises alleviate the issue of
                    <i>callback hell</i> where code is unmanageable and hard to read with its many nests.</p>
                    <h3>Example of callback hell:</h3>
                    <code>
                        <b>//Callback hell</b>
                        function getFrogsWithVitalSigns(params, callback) {
                        let frogIds, frogsListWithVitalSignsData
                        
                        api.fetchFrogs(params, (frogs, error) => {
                          if (error) {
                            console.error(error)
                            return
                          } else {
                            frogIds = frogs.map(({ id }) => id)
                            // The list of frogs did not include their health information, so lets fetch that now
                            api.fetchFrogsVitalSigns(
                              frogIds,
                              (frogsListWithEncryptedVitalSigns, err) => {
                                if (err) {
                                  // do something with error logic
                                } else {
                                  // The list of frogs health info is encrypted. Our friend texted us the secret key to use in this step. This is used to decrypt the list of frogs encrypted health information api.decryptFrogsListVitalSigns(
                                    frogsListWithEncryptedVitalSigns,
                                    'pepsi',
                                    (data, errorr) => {
                                      if (errorrr) {
                                        throw new Error('An error occurred in the final api call')
                                      } else {
                                        if (Array.isArray(data)) {
                                          frogsListWithVitalSignsData = data
                                        } else {
                                          frogsListWithVitalSignsData = data.map(
                                            ({ vital_signs }) => vital_signs,
                                        )
                                        console.log(frogsListWithVitalSignsData)
                                        }
                                      }
                                    },
                                  )
                                }
                              },
                            )
                          }
                        })
                      }                     
                      const frogsWithVitalSigns = getFrogsWithVitalSigns({
                        offset: 50,
                      })
                        .then((result) => {
                          console.log(result)
                        })
                        .catch((error) => {
                          console.error(error)
                        })</code>

                </p>
            </article>
        </section>
        <section class="main-section" id="async">
            <header>
                <h1>Async<h1>
            </header>
        </section>
        <section class="main-section" id="await">
            <header>
                <h1>Await</h1>
            </header>
        </section>
        <section class="main-section" id="error_handling">
            <header>
                <h1>Error Handling</h1>
            </header>
        </section>
        <section class="main-section" id="summary">
            <header>
                <h1>Summary</h1>
            </header>
        </section>
</body>

</html>